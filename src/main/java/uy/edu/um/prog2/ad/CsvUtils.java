package uy.edu.um.prog2.ad;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Enumeration;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import uy.edu.um.prog2.ad.entities.HashTag;
import uy.edu.um.prog2.ad.entities.Tweet;
import uy.edu.um.prog2.ad.entities.User;
import uy.edu.um.prog2.ad.exception.FileNotValidException;
import uy.edu.um.prog2.ad.tads.hash.HashTable;
import uy.edu.um.prog2.ad.tads.hash.table.MyHashTable;
import uy.edu.um.prog2.ad.tads.linked_list.ListaConGenerics;
import uy.edu.um.prog2.ad.tads.linked_list.simple.LinkedList;

/**
 * CSV utils for creating a validating csv files
 *
 * @author Santiago Pereyra
 */
public class CsvUtils {

    private static final String FILE_ERROR_FORMAT = "Wrong format in the file";
    private static final DateTimeFormatter FORMATTER_1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final DateTimeFormatter FORMATTER_2 = DateTimeFormatter.ofPattern("yyyy-MM-dd H:mm:ss");
    private static final String csvFile = "src/main/resources/f1_dataset_test.csv";
    private static final String driversFile = "src/main/resources/drivers.txt";
    private static final ListaConGenerics<User> userLinkedList = new LinkedList<>();
    private static final ListaConGenerics<Tweet> tweetLinkedList = new LinkedList<>();
    private static final ListaConGenerics<HashTag> hashTagLinkedList = new LinkedList<>();
    private static final ListaConGenerics<String> driversLinkedList = new LinkedList<>();

    public static void getDriversFromFile() {
        try (BufferedReader br = new BufferedReader(new FileReader(driversFile))) {
            String line;
            while ((line = br.readLine()) != null) {
                driversLinkedList.add(line.toLowerCase());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void getCsvInfo() {
        try (BufferedReader br = new BufferedReader(new FileReader(csvFile)); CSVParser csvParser = new CSVParser(br, CSVFormat.DEFAULT)) {
            csvParser.iterator().next();
            var autoGeneratedId = 1L;
            for (CSVRecord csvRecord : csvParser) {
                User user = new User();
                Tweet tweet = new Tweet();
                HashTag hashTagValue = new HashTag();
                try {
                    user.setName(csvRecord.get(1));

                    LocalDateTime date = parseDateTime(csvRecord.get(9));
                    tweet.setDate(date);
                    tweet.setContent(csvRecord.get(10).toLowerCase());
                    tweet.setHashTags(hashTagValue);
                    tweet.setId(Long.parseLong(csvRecord.get(0)));
                    tweet.setSource(csvRecord.get(12));
                    tweet.setIsRetweet(Boolean.parseBoolean(csvRecord.get(13)));
                    hashTagValue.setText(csvRecord.get(11).toLowerCase());
                    hashTagValue.setId(autoGeneratedId);
                    if (userLinkedList.contains(user)) {
                        user = userLinkedList.get(user);
                        user.getTweets().add(tweet);
                        user.incrementTweetCount();
                        hashTagLinkedList.add(hashTagValue);
                        tweetLinkedList.add(tweet);
                    } else {

                        user.setId(autoGeneratedId);
                        user.setUserLocation(csvRecord.get(2));
                        user.setUserDescription(csvRecord.get(3).toLowerCase());
                        LocalDateTime userCreated = parseDateTime(csvRecord.get(4));
                        user.setUserCreated(userCreated);
                        user.setUserFollowers(Double.parseDouble(csvRecord.get(5)));
                        user.setUserFriends(Double.parseDouble(csvRecord.get(6)));
                        user.setUserFavourites(Double.parseDouble(csvRecord.get(7)));
                        user.setIsVerified(Boolean.parseBoolean(csvRecord.get(8)));
                        user.getTweets().add(tweet);
                        user.incrementTweetCount();
                        hashTagLinkedList.add(hashTagValue);
                        tweetLinkedList.add(tweet);
                        userLinkedList.add(user);
                        autoGeneratedId++;
                    }

                } catch (Exception ignored) {
                }
            }
        } catch (IOException e) {
            throw new FileNotValidException(FILE_ERROR_FORMAT, e);
        }
    }

    /*
    Top 15 usuarios con más tweets. Este listado debe incluir el nombre de usuario, la
    cantidad de tweets, y si el usuario está verificado o no, ordenado por cantidad de
    tweets en orden descendente. Se espera que esta operación sea de orden n en
    notación Big O
     */
    public static void top15UsersWithMoreTweets() {
        // Ordenar la lista de usuarios por cantidad de tweets en orden descendente
        userLinkedList.sort((user1, user2) -> Integer.compare(user2.getTweetCount(), user1.getTweetCount()));

        // Obtener el límite de usuarios a mostrar (máximo 15)
        int limit = Math.min(15, userLinkedList.size());

        // Mostrar el top 15 de usuarios con más tweets
        for (int i = 0; i < limit; i++) {
            User user = userLinkedList.get(i);
            String verifiedStatus = user.getIsVerified() ? "Verificado" : "No verificado";
            System.out.println(user.getName() + " - Tweets: " + user.getTweetCount() + " - " + verifiedStatus);
        }
    }

    /*
    Cantidad de hashtags distintos para un día dado. El día será ingresado en el formato
    YYYY-MM-DD.
     */
    public static void differentHashTagsForADay(LocalDate date) {
        var differentHashTags = new LinkedList<String>();
        for (int i = 0; i < tweetLinkedList.size(); i++) {
            Tweet tweet = tweetLinkedList.get(i);
            var tweetDate = tweet.getDate().toLocalDate();
            HashTag hashTagObj = hashTagLinkedList.get(i);
            String[] hashTagsSplit = hashTagObj.getText().replaceAll("[\\[\\]' ]", "").split(",");
            if (tweetDate.equals(date)) {
                for (String hashTag : hashTagsSplit) {
                    if (!differentHashTags.contains(hashTag)) {
                        differentHashTags.add(hashTag);
                    }
                }

            }
        }
        System.out.println("Cantidad de hashtags distintos para el día " + date + ": " + differentHashTags.size());
    }


    /*
    Hashtag más usado para un día dado, sin tener en cuenta #f1. El día será ingresado
    en el formato YYYY-MM-DD
     */
    public static void mostUsedHashTagForADay(LocalDate date) {
        MyHashTable<String, Integer> hashTagHashTable = new MyHashTable<>();

        for (int i = 0; i < tweetLinkedList.size(); i++) {
            Tweet tweet = tweetLinkedList.get(i);
            LocalDate tweetDate = tweet.getDate().toLocalDate();


            if (tweetDate.equals(date) && tweet.getHashTags() != null) {
                String[] hashTagsSplit = tweet.getHashTags().getText().replaceAll("[\\[\\]' ]", "").split(",");

                for (String hashTag : hashTagsSplit) {
                    if (!hashTag.equalsIgnoreCase("f1")) {
                        int count = hashTagHashTable.getOrDefault(hashTag, 0);
                        hashTagHashTable.put(hashTag, count + 1);
                    }
                }
            }
        }

        // Encontrar el hashtag más utilizado
        String mostUsedHashTag = null;
        int maxCount = 0;

        Enumeration<String> keys = hashTagHashTable.keys();
        while (keys.hasMoreElements()) {
            String hashTag = keys.nextElement();
            int count = hashTagHashTable.get(hashTag);

            if (count > maxCount) {
                maxCount = count;
                mostUsedHashTag = hashTag;
            }
        }

        System.out.println("Hashtag más utilizado el día " + date + ": " + mostUsedHashTag);
    }

    /*
    Top 7 cuentas con más favoritos. Para este listado se deberá retornar el nombre del
    usuario, junto con la cantidad de favoritos.
     */
    public static void top7UsersWithMoreFavourites() {
        userLinkedList.sort((o1, o2) -> o2.getUserFavourites().compareTo(o1.getUserFavourites()));
        int limit = Math.min(7, userLinkedList.size());
        for (int i = 0; i < limit; i++) {
            System.out.println(userLinkedList.get(i).getName() + " " + userLinkedList.get(i).getUserFavourites());
        }
    }

    /*
    Cantidad de tweets con una palabra o frase específica (que será ingresado como
    parámetro).
     */
    public static void tweetsWithSpecificWordOrPhrase(String wordOrPhrase) {
        var count = 0;
        for (int i = 0; i < tweetLinkedList.size(); i++) {
            Tweet tweet = tweetLinkedList.get(i);
            if (tweet.getContent() != null && tweet.getContent().contains(wordOrPhrase.toLowerCase())) {
                count++;
            }
        }
        System.out.println("Cantidad de tweets con la palabra especificada " + count);
    }

    public static LinkedList<Tweet> filterTweetsByDate(int month, int year){
        LinkedList<Tweet> filteredList = new LinkedList<>();

        for (int i = 0; i < tweetLinkedList.size(); i++){
            Tweet tweet = tweetLinkedList.get(i);
            LocalDateTime fecha=tweet.getDate();
            int mes=fecha.getMonthValue();
            int ano=fecha.getYear();

            if (mes==month && ano==year){
                filteredList.add(tweet);
            }
        }
        return filteredList;
    }

    /*
    Listar los 10 pilotos activos en la temporada 2023 más mencionados en los tweets
    en un mes (este mes será ingresado como 2 parámetros separados, mes y año, por
    consola). Este listado debe incluir el nombre de los pilotos y la cantidad de
    ocurrencias para cada uno de manera ordenada. Se espera que esta operación sea
    de orden n en notación Big O
     */
    public static void getTopTenPilots(int month, int year) {
        getDriversFromFile();
        HashTable<String,Integer> driversMentions= new MyHashTable<>();
        LinkedList<Tweet> filteredTweets=filterTweetsByDate(month,year);

        for (int i = 0; i < filteredTweets.size(); i++){
            for (int j = 0; j < driversLinkedList.size(); j++) {
                String pilot = driversLinkedList.get(j);
                driversMentions.put(pilot, driversMentions.getOrDefault(pilot, 0));
                if (filteredTweets.get(i).getContent().contains(pilot)) {
                    driversMentions.put(pilot, driversMentions.get(pilot) + 1);
                }
            }
        }
        LinkedList<String> top10 = new LinkedList<>();

        for (int i=0; i<10;i++){
            int max=0;
            String pilotoTop=null;
            for (int j=0;j<driversLinkedList.size();j++){
                String pilot = driversLinkedList.get(j);
                if (driversMentions.contains(pilot)){
                    int num = driversMentions.get(pilot);
                    if (num>=max){
                        max=num;
                        pilotoTop=pilot;
                    }
                }
            }
            System.out.println(i + 1 + "- " + pilotoTop + ": con " + max + " menciones");
            top10.add(pilotoTop); //Santi, se necesita una lista?
            driversMentions.remove(pilotoTop);
        }

    }

    public static LocalDateTime parseDateTime(String dateString) {
        try {
            return LocalDateTime.parse(dateString, FORMATTER_1);
        } catch (DateTimeParseException e1) {
            try {
                return LocalDateTime.parse(dateString, FORMATTER_2);
            } catch (DateTimeParseException e2) {
                throw new IllegalArgumentException("Invalid date format: " + dateString);
            }
        }
    }
}
